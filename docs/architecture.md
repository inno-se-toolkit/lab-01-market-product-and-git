## Product Choice

- **Product name**: Telegram  
- **Website**: [https://telegram.org](https://telegram.org)  
- **Description**: Telegram — это облачный мессенджер с фокусом на скорость, безопасность и кроссплатформенность. Он поддерживает обмен сообщениями, медиа, файлами, а также создание групп и каналов с миллионами участников.

## Main components

![Telegram Component Diagram](../../../docs/diagrams/out/telegram/component-diagram/Component%20Diagram.svg)

[Telegram Component Diagram Code](../../../docs/diagrams/src/telegram/component-diagram.puml)

Ниже приведены 5 ключевых компонентов из диаграммы и их назначение:

1. **Client App**  
   Это пользовательский интерфейс (мобильное или десктопное приложение), через который пользователи взаимодействуют с системой: отправляют сообщения, загружают файлы, управляют чатами.

2. **API Gateway**  
   Компонент, который принимает все входящие запросы от клиентов, маршрутизирует их к нужным внутренним сервисам и обеспечивает аутентификацию, ограничение скорости (rate limiting) и логирование.

3. **Message Service**  
   Отвечает за обработку, хранение и доставку текстовых сообщений. Он гарантирует, что сообщения доходят до получателей даже при их офлайн-статусе.

4. **Cloud Storage**  
   Хранит медиафайлы (фото, видео, документы), отправленные пользователями. Использует дедупликацию, чтобы не хранить одинаковые файлы несколько раз.

5. **User Service**  
   Управляет профилями пользователей: регистрация, обновление данных, поиск контактов, управление списками друзей и настройками конфиденциальности.

## Data flow

![Telegram Sequence Diagram](../../../docs/diagrams/out/telegram/sequence-diagram/Sequence%20Diagram.svg)

[Telegram Sequence Diagram Code](../../../docs/diagrams/src/telegram/sequence-diagram.puml)

Рассмотрим группу действий **«Send a message to a contact»**:

1. Пользователь вводит сообщение в **Client App** и нажимает «Отправить».  
2. Клиент отправляет запрос через **API Gateway**, который проверяет токен авторизации.  
3. **Message Service** получает сообщение, сохраняет его в базе данных и определяет, онлайн ли получатель.  
4. Если получатель онлайн — сообщение сразу отправляется через **Push Notification Service** или напрямую по WebSocket.  
5. Если получатель офлайн — сообщение остаётся в очереди до его следующего подключения.  
6. Данные, передаваемые между компонентами: идентификаторы пользователей, содержимое сообщения, временная метка, статус доставки.

## Deployment

![Telegram Deployment Diagram](../../../docs/diagrams/out/telegram/deployment-diagram/Deployment%20Diagram.svg)

[Telegram Deployment Diagram Code](../../../docs/diagrams/src/telegram/deployment-diagram.puml)

Компоненты Telegram развернуты в распределённой глобальной инфраструктуре:
- **Client Apps** работают на устройствах пользователей (iOS, Android, Windows и др.).
- **API Gateway**, **Message Service**, **User Service** и другие микросервисы работают в облаке (предположительно — в собственных дата-центрах Telegram, расположенных в разных регионах для снижения задержек).
- **Cloud Storage** использует распределённую файловую систему с репликацией между регионами.
- Все сервисы взаимодействуют через внутренние API и очереди сообщений (например, Kafka или RabbitMQ).

## Assumptions

1. Я предполагаю, что **Cloud Storage** реализует дедупликацию на уровне хешей файлов, чтобы экономить место при хранении одинаковых медиафайлов.
2. Я предполагаю, что **Message Service** использует распределённую базу данных с горизонтальным масштабированием, чтобы выдерживать нагрузку от сотен миллионов активных пользователей.

## Open questions

1. Как именно реализована доставка сообщений в **секретных чатах**? Используется ли там end-to-end шифрование на уровне протокола, и как это влияет на архитектуру?
2. Как Telegram обеспечивает низкую задержку при глобальном масштабе? Используются ли edge-серверы или CDN для маршрутизации трафика?